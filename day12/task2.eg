# Advent of Code (AoC) - day 12, task 1

import "prelude.eg"
import "os.ego"
import "generator.eg"
import "dictionary.eg"
using System
using OS
using List
using String

def input = let L = read_line stdin in if eof stdin then {} else {L | input}

def to_board =
   do Gen::from_lists |> Gen::zip_2d Gen::space |> Gen::to_lists |> flatten |> Dict::from_list


def to_height = [ 'S' -> to_height 'a' | 'E' -> to_height 'z' |  C -> ord C - ord 'a']

def get_pos = [ D C ->  Dict::to_list D |> foldl [PP (P1, C1) -> if C == C1 then {P1|PP} else PP] {} ]

def neighbors = [ D (X0,Y0) -> 
    map [(DX,DY) -> (X0+DX,Y0+DY)] {(0,-1), (-1,0), (1, 0), (0,1)} |> filter [P -> Dict::has D P ] ]

def mark = [ D P L -> [(_,_) -> D | C -> Dict::set D P (C,  L)] (Dict::get D P) ]

def may = [ D (P0,P1) -> 
    [(C0:char, _) C1:char -> (to_height C1) <= (to_height C0 + 1) | _ _ -> false ] 
    (Dict::get D P0) (Dict::get D P1) ]

def find = [ D -> 
    let (SS, E) = (get_pos D 'S' ++ get_pos D 'a', get_pos D 'E' |> head) in 
    while [(L, PP, D) ->
        map [P -> mark D P L] PP;
        if elem E PP then none
        else let PP = PP |> map [P -> neighbors D P |> map [P0 -> (P,P0)] ] 
                         |> flatten |> filter (may D) |> map snd |> unique  
        in (L+1, PP, D)
        ] (0, SS, D) ]

def main =
    input |> map unpack |> to_board |> find |> [(L, _, _) -> L]
